#!/usr/bin/env ruby
require 'gli'
require 'jtag'

include GLI::App

program_desc 'Autotagging for Jekyll'

version Jtag::VERSION

@config_files = %w{blacklist.txt config.yml stopwords.txt synonyms.yml}
@config_target = File.expand_path("~/.jtag")

# If you have any errors, just raise them
# raise "that command made no sense"

# desc 'Update (overwrite) the post'
# switch [:u,:update]


def config_files_complete?
  @config_files.each do |file|
    return false unless File.exists?(File.join(@config_target,file))
  end
  true
end

desc 'Debug level'
default_value '0'
arg_name 'debug_level'
flag [:d,:debug]

desc 'Run silently'
switch [:s,'silent']

desc "Test (Dry run, don't update files)"
long_desc "Run all commands and show results on the command line, but don't overwrite/update any files"
default_value false
switch [:t,'test']

desc 'Update and notify user of configuration files location'
command :config do |c|
  c.desc 'Reset all configuration files to default values'
  c.switch [:r,'reset']

  c.skips_pre
  c.action do |global_options,options,args|
    if options[:r]
      print "Are you sure you want to reset all config files? y/N: "
      response = STDIN.gets.strip
      if response =~ /^y/i
        write_config(true)
        puts "Config files reset"
      end
    else
      write_config(false)
    end
  end
end

def write_config(atomic=false)
  gem_root = Gem.loaded_specs['jtag'].full_gem_path
  gem_lib = File.join(gem_root, 'lib')
  config_source = File.join(gem_lib,'/jtag/config_files')



  unless File.directory?(@config_target) || atomic
    FileUtils.cp_r(config_source,@config_target)
    puts "Configuration files are located in the folder: " + @config_target
    puts %Q{Make sure that "tags_location" in config.yml is set to your tags.json url.}
    puts "Configuration files written to #{@config_target}"
  end

  @config_files.each do |file|
    unless File.exists?(File.join(@config_target,file))
      source_file = File.join(config_source,file)
      target_file = File.join(@config_target,file)
      FileUtils.cp(source_file, target_file)
      puts "Config file #{file} added."
    end
  end
  puts
  puts "Configuration files are located in the folder: " + @config_target
  puts %Q{Make sure that "tags_location" in the config.yml file is set to your tags json file.}
end

desc 'List tags, optionally filter for keyword'
long_desc 'This command can be used to find the exact format for a given tag to keep spaces, underscores, capitalization and pluralization consistent'
arg_name 'keyword'
command :find do |c|
  c.action do |global_options,options,args|
    tags = @jt.get_tags({:counts => true})
    if args.length > 1
      raise "Too many arguments"
    elsif args.length == 1
      tags.each {|tag|
        next unless tag
        puts "[#{tag['count']}] #{tag['name']}" if tag['name'] =~ /#{args[0]}/i
      }
    else
      tags.each {|tag|
        next unless tag
        puts "[#{tag['count']}] #{tag['name']}"
      }
    end
  end
end

desc 'Show the current tags for posts'
arg_name 'filenames'
command :tags do |c|
  c.action do |global_options,options,args|
    args.each{|file|
      tags = @jt.post_tags(file)
      puts
      puts file + ":"
      if tags.empty? || tags.nil?
        puts "No tags in post"
      else
        tags.each {|tag|
          puts "- #{tag}"
        }
      end
    }
  end
end

desc 'Merge multiple tags into one'
long_desc 'Scans the specified posts for any of the tags, merging any found into the last one in the list'
arg_name 'tags to merge merge_tag'
command :merge do |c|

  c.action do |global_options, options, args|
    files = []
    tags = []
    args.length.times do
      arg = args.pop
      if File.exists?(arg)
        files.push(arg)
      else
        exit_now! "No valid filename in arguments" if files.empty?
        tags.push(arg)
      end
    end

    exit_now! "Needs at least two tag inputs, one or more to merge, one to merge to" if tags.length < 2
    merge_tag = tags.pop
    files.each {|file|
      new_tags = @jt.merge_tags(tags,merge_tag,file)
      unless global_options[:t]
        @jt.update_file_tags(file, new_tags)
        puts
        puts "Updated tags for #{file}" unless global_options[:s]
      end
      unless global_options[:s]
        puts
        puts file + ":"
        puts new_tags.join("\n")
      end
    }
  end
end


desc 'Blacklist a specific tag'
arg_name 'tag [tag2...]'
command :blacklist do |c|
  c.desc "Remove (unblacklist) the arguments"
  c.switch [:r,'remove']

  c.action do |global_options,options,args|
    if options[:r]
      @jt.unblacklist(args)
      puts "Removed #{args.join(", ")} from blacklist."
    else
      @jt.blacklist(args)
      puts "Blacklisted #{args.join(", ")}."
    end
  end
end

desc 'Add tags to post'
arg_name 'tags to add from_post_file_or_pattern'
command :add do |c|

  c.action do |global_options,options,args|
    files = []
    new_tags = []
    args.length.times do
      arg = args.pop
      if File.exists?(arg)
        files.push(arg)
      else
        exit_now! "No valid filename in arguments" if files.empty?
        new_tags.push(arg)
      end
    end

    exit_now! "No tags found in arguments" if new_tags.empty?

    files.each {|file|
      tags = @jt.post_tags(file)
      tags.concat(new_tags)
      tags.uniq!
      tags.sort!
      unless global_options[:t]
        @jt.update_file_tags(file,tags)
        puts "Updated tags for #{file}" unless global_options[:s]
      end
      unless global_options[:s]
        puts
        puts File.basename(file) + ":"
        puts tags.join("\n")
      end
    }
  end
end

desc 'Remove tags from a post'
arg_name 'tags to remove from_post_file_or_pattern'
command :remove do |c|

  c.action do |global_options,options,args|
    files = []
    remove_tags = []
    args.length.times do
      arg = args.pop
      if File.exists?(arg)
        files.push(arg)
      else
        exit_now! "No valid filename in arguments" if files.empty?
        remove_tags.push(arg)
      end
    end

    exit_now! "No tags found in arguments" if remove_tags.empty?

    files.each {|file|
      tags = @jt.post_tags(file)
      remove_tags.each { |d|
        tags.delete_if { |tag| tag == d }
      }
      unless global_options[:t]
        @jt.update_file_tags(file,tags)
        puts "Updated tags for #{file}" unless global_options[:s]
      end
      unless global_options[:s]
        puts
        puts File.basename(file) + ":"
        puts tags.join("\n")
      end
    }
  end
end

desc 'Generate a list of recommended tags, optionally updating the file'
arg_name 'filename'
command :tag do |c|
  c.action do |global_options,options,args|

    args.each {|file|
      if File.exists?(File.expand_path(file))
        input = IO.read(File.expand_path(file))
        suggestions = @jt.suggest(input)
        unless global_options[:t]
          if @jt.update_file_tags(file, suggestions)
            unless global_options[:s]
              puts
              puts "Updated file #{file} with:"
            end
          else
            unless global_options[:s]
              puts
              puts "Failed to update #{file} with:"
            end
          end
        end
        if !global_options[:s] || global_options[:t]
          puts
          puts File.basename(file) + ":"
          suggestions.sort!.each {|tag|
            puts "- #{tag}"
          }
        end
        suggestions = nil
      else
        raise "No such file: #{file}"
      end
    }
  end
end

## TODO: Add a feature for converting YAML tags to OpenMeta or Mavericks tags
# desc 'Describe omtag here'
# arg_name 'Describe arguments to omtag here'
# command :omtag do |c|
#   c.action do |global_options,options,args|
##   system %Q{openmeta -a "#{@auto_tags.uniq.join('" "')}" -p "#{@update_file}"}
#     puts "omtag command ran"
#   end
# end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only

  unless config_files_complete?
    write_config
    puts "Missing config files written to #{@config_target}. Please check your configuration."
    return false
  end

  configfile = File.expand_path("~/.jtag/config.yml")

  global[:config] = YAML::load(File.open(configfile,"r"))
  global[:support] = File.expand_path("~/.jtag")
  @jt = JTag.new(global[:support], global[:config])

  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
